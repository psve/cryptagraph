//! Implementation of DES.

use crate::sbox::Sbox;
use crate::cipher::{CipherStructure, Cipher};
use crate::property::PropertyType;

/*****************************************************************
                            DES
******************************************************************/

/// A structure representing the DES cipher.
#[derive(Clone)]
pub struct Des {
    size: usize,
    key_size: usize,
    sbox0: Sbox,
    sbox1: Sbox,
    sbox2: Sbox,
    sbox3: Sbox,
    sbox4: Sbox,
    sbox5: Sbox,
    sbox6: Sbox,
    sbox7: Sbox,
    permute: [usize; 32],
    expand: [usize; 48]
}

impl Des {
    /// Create a new instance of the cipher.
    pub fn new() -> Des {
        let table0 = vec![0xd,0x1,0x2,0xf,0x8,0xd,0x4,0x8,0x6,0xa,0xf,0x3,0xb,0x7,0x1,0x4,0xa,0xc,0x9,0x5,0x3,0x6,0xe,0xb,0x5,0x0,0x0,0xe,0xc,0x9,0x7,0x2,0x7,0x2,0xb,0x1,0x4,0xe,0x1,0x7,0x9,0x4,0xc,0xa,0xe,0x8,0x2,0xd,0x0,0xf,0x6,0xc,0xa,0x9,0xd,0x0,0xf,0x3,0x3,0x5,0x5,0x6,0x8,0xb];
        let table1 = vec![0x4,0xd,0xb,0x0,0x2,0xb,0xe,0x7,0xf,0x4,0x0,0x9,0x8,0x1,0xd,0xa,0x3,0xe,0xc,0x3,0x9,0x5,0x7,0xc,0x5,0x2,0xa,0xf,0x6,0x8,0x1,0x6,0x1,0x6,0x4,0xb,0xb,0xd,0xd,0x8,0xc,0x1,0x3,0x4,0x7,0xa,0xe,0x7,0xa,0x9,0xf,0x5,0x6,0x0,0x8,0xf,0x0,0xe,0x5,0x2,0x9,0x3,0x2,0xc];
        let table2 = vec![0xc,0xa,0x1,0xf,0xa,0x4,0xf,0x2,0x9,0x7,0x2,0xc,0x6,0x9,0x8,0x5,0x0,0x6,0xd,0x1,0x3,0xd,0x4,0xe,0xe,0x0,0x7,0xb,0x5,0x3,0xb,0x8,0x9,0x4,0xe,0x3,0xf,0x2,0x5,0xc,0x2,0x9,0x8,0x5,0xc,0xf,0x3,0xa,0x7,0xb,0x0,0xe,0x4,0x1,0xa,0x7,0x1,0x6,0xd,0x0,0xb,0x8,0x6,0xd];
        let table3 = vec![0x2,0xe,0xc,0xb,0x4,0x2,0x1,0xc,0x7,0x4,0xa,0x7,0xb,0xd,0x6,0x1,0x8,0x5,0x5,0x0,0x3,0xf,0xf,0xa,0xd,0x3,0x0,0x9,0xe,0x8,0x9,0x6,0x4,0xb,0x2,0x8,0x1,0xc,0xb,0x7,0xa,0x1,0xd,0xe,0x7,0x2,0x8,0xd,0xf,0x6,0x9,0xf,0xc,0x0,0x5,0x9,0x6,0xa,0x3,0x4,0x0,0x5,0xe,0x3];
        let table4 = vec![0x7,0xd,0xd,0x8,0xe,0xb,0x3,0x5,0x0,0x6,0x6,0xf,0x9,0x0,0xa,0x3,0x1,0x4,0x2,0x7,0x8,0x2,0x5,0xc,0xb,0x1,0xc,0xa,0x4,0xe,0xf,0x9,0xa,0x3,0x6,0xf,0x9,0x0,0x0,0x6,0xc,0xa,0xb,0x1,0x7,0xd,0xd,0x8,0xf,0x9,0x1,0x4,0x3,0x5,0xe,0xb,0x5,0xc,0x2,0x7,0x8,0x2,0x4,0xe];
        let table5 = vec![0xa,0xd,0x0,0x7,0x9,0x0,0xe,0x9,0x6,0x3,0x3,0x4,0xf,0x6,0x5,0xa,0x1,0x2,0xd,0x8,0xc,0x5,0x7,0xe,0xb,0xc,0x4,0xb,0x2,0xf,0x8,0x1,0xd,0x1,0x6,0xa,0x4,0xd,0x9,0x0,0x8,0x6,0xf,0x9,0x3,0x8,0x0,0x7,0xb,0x4,0x1,0xf,0x2,0xe,0xc,0x3,0x5,0xb,0xa,0x5,0xe,0x2,0x7,0xc];
        let table6 = vec![0xf,0x3,0x1,0xd,0x8,0x4,0xe,0x7,0x6,0xf,0xb,0x2,0x3,0x8,0x4,0xe,0x9,0xc,0x7,0x0,0x2,0x1,0xd,0xa,0xc,0x6,0x0,0x9,0x5,0xb,0xa,0x5,0x0,0xd,0xe,0x8,0x7,0xa,0xb,0x1,0xa,0x3,0x4,0xf,0xd,0x4,0x1,0x2,0x5,0xb,0x8,0x6,0xc,0x7,0x6,0xc,0x9,0x0,0x3,0x5,0x2,0xe,0xf,0x9];
        let table7 = vec![0xe,0x0,0x4,0xf,0xd,0x7,0x1,0x4,0x2,0xe,0xf,0x2,0xb,0xd,0x8,0x1,0x3,0xa,0xa,0x6,0x6,0xc,0xc,0xb,0x5,0x9,0x9,0x5,0x0,0x3,0x7,0x8,0x4,0xf,0x1,0xc,0xe,0x8,0x8,0x2,0xd,0x4,0x6,0x9,0x2,0x1,0xb,0x7,0xf,0x5,0xc,0xb,0x9,0x3,0x7,0xe,0x3,0xa,0xa,0x0,0x5,0x6,0x0,0xd];
        
        let permute = [7,28,21,10,26,2,19,13,23,29,5,0,18,8,24,30,22,1,14,27,6,9,17,31,15,4,20,3,11,12,25,16];
        let expand = [31,0,1,2,3,4,3,4,5,6,7,8,7,8,9,10,11,12,11,12,13,14,15,16,15,16,17,18,19,20,19,20,21,22,23,24,23,24,25,26,27,28,27,28,29,30,31,0];

        Des{size: 64,
            key_size: 56, 
            sbox0: Sbox::new(6, 4, table0),
            sbox1: Sbox::new(6, 4, table1),
            sbox2: Sbox::new(6, 4, table2),
            sbox3: Sbox::new(6, 4, table3),
            sbox4: Sbox::new(6, 4, table4),
            sbox5: Sbox::new(6, 4, table5),
            sbox6: Sbox::new(6, 4, table6),
            sbox7: Sbox::new(6, 4, table7),
            permute,
            expand
        }
    }

    /// A "linear" version of the inverse expansion. Used for sbox_mask_transform
    fn inv_expand(&self, input: u128) -> u128 {
        let mut output = 0;

        for (i, j) in self.expand.iter().enumerate() {
            output ^= ((input >> i) & 0x1) << j;
        }

        output   
    }
}


impl Cipher for Des {
    fn structure(&self) -> CipherStructure {
        CipherStructure::Feistel
    }

    fn size(&self) -> usize {
        self.size
    }

    fn key_size(&self) -> usize {
        self.key_size
    }

    fn num_sboxes(&self) -> usize {
        16
    }

    fn sbox(&self, i: usize) -> &Sbox {
        match i {
            0  => &self.sbox0,
            1  => &self.sbox1,
            2  => &self.sbox2,
            3  => &self.sbox3,
            4  => &self.sbox4,
            5  => &self.sbox5,
            6  => &self.sbox6,
            7  => &self.sbox7,
            8  => &self.sbox0,
            9  => &self.sbox1,
            10 => &self.sbox2,
            11 => &self.sbox3,
            12 => &self.sbox4,
            13 => &self.sbox5,
            14 => &self.sbox6,
            15 => &self.sbox7,
            _ => panic!("S-box index out of bounds")
        }        
    }

    fn sbox_pos_in(&self, i: usize) -> usize {
        i*self.sbox(i).size_in()
    }

    fn sbox_pos_out(&self, i: usize) -> usize {
        i*self.sbox(i).size_out()
    }

    fn linear_layer(&self, input: u128) -> u128{
        let mut output = 0;

        for (i, j) in self.permute.iter().enumerate() {
            output ^= ((input >> j) & 0x1) << i;
        }

        output
    }

    fn linear_layer_inv(&self, input: u128) -> u128{
        let mut output = 0;

        for (i, j) in self.permute.iter().enumerate() {
            output ^= ((input >> i) & 0x1) << j;
        }

        output   
    }

    fn reflection_layer(&self, _input: u128) -> u128 {
        panic!("Not implemented for this type of cipher")
    }

    fn key_schedule(&self, _rounds : usize, key: &[u8]) -> Vec<u128> {
        if key.len() * 8 != self.key_size {
            panic!("invalid key-length");
        }

        panic!("Not implemented")
    }

    fn encrypt(&self, _input: u128, _round_keys: &[u128]) -> u128 {
        panic!("Not implemented")
    }

    fn decrypt(&self, _input: u128, _round_keys: &[u128]) -> u128 {
        panic!("Not implemented")
    }

    fn name(&self) -> String {
        String::from("DES")
    }
    
    fn sbox_mask_transform(&self, 
                           input: u128, 
                           output: u128, 
                           property_type: PropertyType) 
                           -> (u128, u128) {
        match property_type {
            PropertyType::Linear => {
                let input = self.inv_expand(input & 0xffffffffffff)
                          ^ (self.inv_expand(input >> 48) << 32);
                let output = self.linear_layer(output & 0xffffffff)
                           ^ ((self.linear_layer(output >> 32)) << 32);

                let mut alpha = ((output & 0xffffffff) << 32)
                              ^ (output >> 32);
                alpha ^= input & 0xffffffff;

                let mut beta = ((output & 0xffffffff) << 32)
                             ^ (output >> 32);
                beta ^= input & 0xffffffff00000000;

                (alpha, beta)
            },
            PropertyType::Differential => {
                panic!("Differentials are not implemented for DES");
            }
        }
    }

    #[inline(always)]
    fn whitening(&self) -> bool { 
        false 
    }
}

impl Default for Des {
    fn default() -> Self {
        Des::new()
    }
}