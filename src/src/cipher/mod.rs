use property::PropertyType;
use utility;

/**
A structure that represents an S-box.

size    Size of the S-box input in number of bits.
table   The table that describes the S-box.
lat     The linear approximation table for the S-box.
ddt     The difference distribution table for the S-box.
*/
#[derive(Clone, Debug)]
pub struct Sbox {
    pub size: usize,
    pub table: Vec<u8>,
    pub lat: Vec<Vec<usize>>,
    pub ddt: Vec<Vec<usize>>,
}

impl Sbox {
    /**
    Generates a new S-box from a table.

    size    Size of the S-box in bits
    table   A table discribing the S-box transformation.
    */
    fn new(size: usize,
           table: Vec<u8>) -> Sbox {
        let lat = Sbox::generate_lat(&table[..], size);
        let ddt = Sbox::generate_ddt(&table[..], size);

        Sbox {
            size: size,
            table: table,
            lat: lat,
            ddt: ddt
         }
    }

    /**
    Generates the LAT associated with the S-box.

    table       The table discribing the S-box.
    sbox_size   The size of the S-box in bits.
    */
    fn generate_lat(table: &[u8], sbox_size: usize) -> Vec<Vec<usize>> {
        let lat_size = 1 << sbox_size;
        let mut lat = vec![vec![0; lat_size]; lat_size];

        for plaintext in 0..lat_size {
            let ciphertext = table[plaintext];

            for alpha in 0..lat_size {
                for beta in 0..lat_size {
                    let parity = utility::parity_masks(plaintext as u128,
                                                       ciphertext as u128,
                                                       alpha as u128,
                                                       beta as u128);

                    lat[alpha as usize][beta as usize] += (1 - parity) as usize;
                }
            }
        }

        lat
    }

    /**
    Generates the DDT associated with the S-box.

    table       The table discribing the S-box.
    sbox_size   The size of the S-box in bits.
    */
    fn generate_ddt(table: &[u8], sbox_size: usize) -> Vec<Vec<usize>> {
        let ddt_size = 1 << sbox_size;
        let mut ddt = vec![vec![0; ddt_size]; ddt_size];

        for plaintext_0 in 0..ddt_size {
            let ciphertext_0 = table[plaintext_0];

            for in_diff in 0..ddt_size {
                let plaintext_1 = plaintext_0 ^ in_diff;
                let ciphertext_1 = table[plaintext_1];

                ddt[in_diff][(ciphertext_0 ^ ciphertext_1) as usize] += 1;
            }
        }

        ddt
    }

    /**
    Returns the value of a balanced linear approximation.
    */
    pub fn linear_balance(&self) -> i16 {
        (1 << (self.size - 1)) as i16
    }

    /**
    Returns the probability of an impossible differential.
    */
    pub fn differential_zero(&self) -> i16 {
        0
    }

    /**
    Returns a bitmask the corresponds to the S-box size.
    */
    pub fn mask(&self) -> u128 {
        (1 << self.size) - 1
    }
}

/**
A structure describing a type of cipher.
*/
#[derive(PartialEq, Eq)]
pub enum CipherStructure {
    Spn,
    Feistel,
    Prince
}

/**
A trait defining a cipher
*/
pub trait Cipher: Sync {
    /**
    Returns the design type of the cipher.
    */
    fn structure(&self) -> CipherStructure;

    /**
    Returns the size of the cipher input in bits.
    */
    fn size(&self) -> usize;

    /**
    Returns key-size in bits
    */
    fn key_size(&self) -> usize;

    /**
    Returns the number of S-boxes in the non-linear layer.
    */
    fn num_sboxes(&self) -> usize;

    /**
    Returns the S-box of the cipher.
    */
    fn sbox(&self) -> &Sbox;

    /**
    Applies the linear layer of the cipher.

    input   The input to the linear layer.
    */
    fn linear_layer(&self, input: u128) -> u128;

    /**
    Applies the inverse linear layer of the cipher.
    
    input   The input to the inverse linear layer. 
    */
    fn linear_layer_inv(&self, input: u128) -> u128;

    /**
    Applies the reflection layer for Prince like ciphers.
    For all other cipher types, this can remain unimplemented.

    input   The input to the reflection layer.
    */
    fn reflection_layer(&self, input: u128) -> u128;

    /**
    Computes a vector of round key from a cipher key.

    rounds      Number of rounds to generate keys for.
    key         The master key to expand.
    */
    fn key_schedule(&self, rounds : usize, key: &[u8]) -> Vec<u128>;

    /**
    Performs encryption with the cipher.

    input       Plaintext to be encrypted.
    round_keys  Round keys generated by the key-schedule.
    */
    fn encrypt(&self, input: u128, round_keys: &Vec<u128>) -> u128;

    /**
    Performs decryption with the cipher.

    input       Ciphertext to be decrypted.
    round_keys  Round keys generated by the key-schedule.
    */
    fn decrypt(&self, input: u128, round_keys: &Vec<u128>) -> u128;

    /**
    Returns the name of the cipher.
    */
    fn name(&self) -> String;

    /**
    Transforms the input and output mask of the S-box layer to an
    input and output mask of a round.

    input           Input mask to the S-box layer.
    output          Output mask to the S-box layer.
    property_type   Type of the property determining the transform.
    */
    #[allow(unused_variables)]
    fn sbox_mask_transform(&self,
                           input: u128,
                           output: u128,
                           property_type: PropertyType)
                           -> (u128, u128);

    /**
     * Pre-whiteing key used?
     * (rounds + 1) round keys
     *
     * This is the case for most ciphers
     */
    #[inline(always)]
    fn whitening(&self) -> bool { 
        true 
    }
}

mod aes;
mod epcbc48;
mod epcbc96;
mod fly;
mod gift64;
mod gift128;
mod khazad;
mod klein;
mod led;
mod mantis;
mod mibs;
mod midori;
mod present;
mod pride;
mod prince;
mod puffin;
mod qarma;
mod rectangle;
mod skinny64;
mod skinny128;
mod twine;

/**
Converts the name of a cipher to an instance of that cipher.
*/
pub fn name_to_cipher(name : &str) -> Option<Box<Cipher>> {
    match name {
        "aes"       => Some(Box::new(aes::new())),
        "epcbc48"   => Some(Box::new(epcbc48::new())),
        "epcbc96"   => Some(Box::new(epcbc96::new())),
        "fly"       => Some(Box::new(fly::new())),
        "gift64"    => Some(Box::new(gift64::new())),
        "gift128"   => Some(Box::new(gift128::new())),
        "khazad"    => Some(Box::new(khazad::new())),
        "klein"     => Some(Box::new(klein::new())),
        "led"       => Some(Box::new(led::new())),
        "mantis"    => Some(Box::new(mantis::new())),
        "mibs"      => Some(Box::new(mibs::new())),
        "midori"    => Some(Box::new(midori::new())),
        "present"   => Some(Box::new(present::new())),
        "pride"     => Some(Box::new(pride::new())),
        "prince"    => Some(Box::new(prince::new())),
        "puffin"    => Some(Box::new(puffin::new())),
        "qarma"     => Some(Box::new(qarma::new())),
        "rectangle" => Some(Box::new(rectangle::new())),
        "skinny64"  => Some(Box::new(skinny64::new())),
        "skinny128" => Some(Box::new(skinny128::new())),
        "twine"     => Some(Box::new(twine::new())),
        _ => None
    }
}
